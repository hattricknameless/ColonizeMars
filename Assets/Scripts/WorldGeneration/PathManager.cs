using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using AlanZucconi.AI.PF;
using System;
using System.Linq;

public class PathManager : MonoBehaviour {
    
    //References
    public static PathManager pathManager;
    private WorldGenerator worldGenerator;

    //Data Structure
    public Dictionary<Vector3Int, PathAnchor> pathGrid = new();
    public Dictionary<Vector3Int, NaturalResource> resourceGrid = new();
    public HashSet<Vector3Int> blockedPath = new();
    public List<Vector3Int> selectedPaths = new();
    private bool isSelectable = false;

    //Path Finding
    private Vector3Int gridLimit;
    private WeightedGraph<Vector3Int, Edge> pathGraph = new();
    private GameObject lineContainer;

	private void Awake() {
        pathManager = this;
		worldGenerator = WorldGenerator.worldGenerator;
	}
    
    private void Start() {
        lineContainer = new GameObject("LineContainer");
        gridLimit = worldGenerator.worldSize * 3;
    }

    public void RegisterToGraph() {
        Vector3Int[] directions = {Vector3Int.left, Vector3Int.right, Vector3Int.forward, Vector3Int.back};
        foreach (Vector3Int key in pathGrid.Keys) {
            foreach (Vector3Int direction in directions) {
                //If key found, connect the cells
                Vector3Int nearestKey = FindNearestKey(key, direction);
                if (nearestKey != new Vector3Int(-1, -1, -1)) {
                    pathGraph.Connect(key, nearestKey, CellDistance(key, nearestKey));
                    if (pathGraph.Outgoing(nearestKey).Select(p => p.Item1).ToList().Contains(key)) {
                        // DrawLineBetweenKeys(key, nearestKey);
                    }
                    
                }
            }
            if (pathGraph.Outgoing(key).Count() > 4) {
                Debug.LogWarning($"exceed connection limit, key {key}");
            }
        }
    }

    private Vector3Int FindNearestKey(Vector3Int origin, Vector3Int direction) {
        Vector3Int current = origin;

        // Search along the direction until we hit the grid limit or find a key
        while (Mathf.Abs(current.x) <= gridLimit.x && Mathf.Abs(current.z) <= gridLimit.z) {
            current += direction;
            
            // //Check if the connection is blocked by terrian
            // for (int i = current.y; i < gridLimit.y; i++) {
            //     if (blockedPath.Contains(new Vector3Int(current.x, i, current.z))) {
            //         return new Vector3Int(-1, -1, -1);
            //     }
            // }

            for (int i = 0; i < gridLimit.y; i++) {
                if (pathGrid.ContainsKey(new Vector3Int(current.x, i, current.z))) {
                    return new Vector3Int(current.x, i, current.z);
                }
            }
        }

        //If no key has been found
        return new Vector3Int(-1, -1, -1);
    }

    private float CellDistance(Vector3Int origin, Vector3Int end) {
        float horizontalDistance = Mathf.Abs(origin.x - end.x) + Math.Abs(origin.z - end.z);
        //If two cell are not next to each other, add 3 distance
        if (horizontalDistance > 1) horizontalDistance = horizontalDistance * 2 + 3;
        
        float verticalDistance = Mathf.Abs(origin.y - end.y);
        //If two cell are require vertical movement, add 1 distance
        if (verticalDistance > 0) verticalDistance += 2;

        return horizontalDistance + verticalDistance;
    }

    //The drawline function is generated by copilot
    private void DrawLineBetweenKeys(Vector3Int start, Vector3Int end) {
        // Create a new GameObject for the LineRenderer
        GameObject lineObject = new GameObject($"Line_{start}_{end}");
        lineObject.transform.SetParent(lineContainer.transform);
        LineRenderer lineRenderer = lineObject.AddComponent<LineRenderer>();

        // Configure the LineRenderer
        lineRenderer.startWidth = 0.1f;
        lineRenderer.endWidth = 0.1f;
        lineRenderer.positionCount = 2;
        lineRenderer.useWorldSpace = true;

        // Set the positions of the line
        lineRenderer.SetPosition(0, pathGrid[start].transform.position);
        lineRenderer.SetPosition(1, pathGrid[end].transform.position);

        // Optionally, set a material or color for the line
        lineRenderer.material = new Material(Shader.Find("Sprites/Default"));
        lineRenderer.startColor = Color.green;
        lineRenderer.endColor = Color.green;
    }

    public void PlaceBuilding() {
        List<PathAnchor> occupiedPaths = new();
        foreach (Vector3Int index in selectedPaths) {
            occupiedPaths.Add(pathGrid[index]);
        }

        // foreach (Vector3Int index in selectedPaths) {
        //     pathGrid[index].isOccupied = true;
        //     var outgoingEdges = pathGraph.Outgoing(index).ToList();

        //     // Disconnect each outgoing edge
        //     foreach (var edge in outgoingEdges) {
        //         pathGraph.Disconnect(index, edge.Item1);
        //     }
        // }
    }

    public Vector3Int FindNearestResource(Vector3Int from) {
        Debug.Log($"Find resource from {from}");
        Vector3Int destination = new Vector3Int(-1, -1, -1);
        float shortestDistance = float.MaxValue;

        foreach (NaturalResource resource in resourceGrid.Values) {
            if (resource.depositValue <= 0) continue; // Skip depleted resources

            float distance = Mathf.Abs(from.x - resource.cellIndex.x) + Mathf.Abs(from.z - resource.cellIndex.z);
            if (distance < shortestDistance) {
                shortestDistance = distance;
                destination = resource.cellIndex;
            }
        }

        return destination;
    }

    public List<Vector3Int> PathfindingTo(Vector3Int from, Vector3Int to) {
        List<(Vector3Int, Edge)> path = pathGraph.Dijkstra(from, to);
        return path.Select(p => p.Item1).ToList();
    }

    public void ResetDataStructure() {
        pathGrid = new();
        resourceGrid = new();
        blockedPath = new();
    }

    public void RegisterToPathGrid(PathAnchor pathAnchor) {
        pathGrid[pathAnchor.cellIndex] = pathAnchor;
    }

    public void RegisterToResourceGrid(NaturalResource resource) {
        resourceGrid[resource.cellIndex] = resource;
    }

    public void RegisterToBlockedPath(Vector3Int key) {
        blockedPath.Add(key);
    }

    public void EnableSelection() {
        //Hit confirm generation enables selection
        isSelectable = true;
    }

    public void OnCursorHoverX1(Vector3Int cellIndex) {
        if (!isSelectable) return;
        pathGrid[cellIndex].SelectAll();
        selectedPaths.Add(cellIndex);
    }

    public void OnCursorHoverX2(Vector3Int cellIndex) {
        if (!isSelectable) return;

        bool selectSuccess = true;
        Vector3Int[] directions = {new Vector3Int(1, 0, 0), new Vector3Int(0, 0, 1), new Vector3Int(1, 0, 1)};
        foreach (Vector3Int direction in directions) {
            if (!pathGrid.ContainsKey(cellIndex + direction)) {
                selectSuccess = false;
                break;
            }
        }
        if (selectSuccess) {
            //Draw the larger selection frame
            pathGrid[cellIndex].SelectDown();
            selectedPaths.Add(cellIndex);
            pathGrid[cellIndex + directions[0]].SelectRight();
            selectedPaths.Add(cellIndex + directions[0]);
            pathGrid[cellIndex + directions[1]].SelectLeft();
            selectedPaths.Add(cellIndex + directions[1]);
            pathGrid[cellIndex + directions[2]].SelectUp();
            selectedPaths.Add(cellIndex + directions[2]);
        }
        else {
            OnCursorHoverX1(cellIndex);
        }
    }
    
    public void OnCursorExit() {
        if (!isSelectable) return;
        foreach (Vector3Int cellIndex in selectedPaths) {
            pathGrid[cellIndex].DeselectAll();
        }
        selectedPaths.Clear();
    }
}